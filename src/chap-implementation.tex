\chapter{Implementacja i~sposób działania CMA}

Podstawowym założeniem CMA jest umożliwienie alokowania dużych
obszarów ciągłych fizycznie bez konieczneści rezerwacji na wyłączność
dużej ilości pamięci.  Aby to umożliwić, CMA korzysta z~mechanizmu
migracji stron opisanego w~podrozdziale \ref{sec:migratetype}.

\section{Typ migracji CMA}\label{sec:migrate-cma}

Migracja jest możliwa tylko dla stron ruchomych.  Niestety, przed
zaimplementowaniem CMA, w~Linuksie nie istniał mechanizm, który
pozwalałby zagwarantować, aby w~systemie istniał duży obszar, w~którym
strony są wolne albo ruchome.  Ponieważ (jak opisałem w~podrozdziale
\ref{sec:type-change}) jądro dopuszcza alokacje nieruchomych stron
z~bloków stron oznaczonych jako przechowujące strony ruchome, a~także
posiada mechanizm na skutek którego bloki stron zmieniają swój typ,
oznaczenie bloku stron jako ruchome nie gwarantuje, że tylko strony
ruchome będą alokowane z~tego bloku stron.

Z~tego powodu, aby CMA dobrze działała, pierwszym krokiem było
stworzenie nowego typu migracji, nazwanym po prostu typem migracji CMA
(\code|MIGRATE_CMA|).  Typ ten posiada dwie bardzo istotne cechy:

\begin{itemize}
\item Z~bloków stron oznaczonych typem CMA mogą być alokowane tylko
  strony ruchome.  Innymi słowy, typ migracji CMA istnieje w~liście
  zapasowych typów migracji jedynie dla typu ruchomego.
\item Blok oznaczony typem CMA nie zmienia swojego typu (na skutek
  działania alokatora stron).
\end{itemize}

O~ile pierwsza właściwość jest stosunkowo prosta do osiągnięcia,
zagwarantowania niezmienności typu bloku stron wymagało
zidentyfikowania wszystkich sytuacji, w~których blok może zmienić swój
typ (a~także sytuacji, w~których strony mogą trafić na listy wolnych
stron dla typu niezgodnego z~typem bloku, do którego należą) i~dodanie
odpowiednich warunków zapewniających, że niepożądana zmiana nie
nastąpi.

\section{Alokowanie wybranego obszaru pamięci}\label{sec:alloc-contig-range}

W~sytuacji, gdy istnieje gwarancja, że dany zakres stron posiada
jedynie strony wolne i~ruchome, można przystąpić do jej alokacji.
Drugim krokiem implementowania CMA było zatem stworzenie funkcji,
która dostaje jako argument zakres stron, a~następnie migruje
wszystkie zajęte strony, a~wolne usuwa z~listy wolnych stron.

Wydruk \ref{lst:alloc-contig-range} przedstawia skrócony (bo
pozbawiony sprawdzania błędów oraz komentarzy) kod źródłowy funkcji
\code|alloc_contig_range| znajdującej się w~Linuksie 3.5.  Jak
można się było domyślać, jest ona bardziej skomplikowana, niżby to
wynikało z~wcześniejszego paragrafu.

\begin{lstlisting}[float=tbhp,caption=Skrócony wydruk funkcji
    \code|alloc_conting_range| z Linuksa 3.5.,label=lst:alloc-contig-range]
int alloc_contig_range(unsigned long start, unsigned long end,
		       unsigned migratetype)
{
	struct zone *zone = page_zone(pfn_to_page(start));
	unsigned long outer_start, outer_end;
	int ret = 0, order;

	start_isolate_page_range(pfn_max_align_down(start),
				 pfn_max_align_up(end), migratetype);

	__alloc_contig_migrate_range(start, end);

	lru_add_drain_all();
	drain_all_pages();

	order = 0;
	outer_start = start;
	while (!PageBuddy(pfn_to_page(outer_start))) {
		outer_start &= ~0UL << ++order;
	}

	outer_end = isolate_freepages_range(outer_start, end);

	if (start != outer_start)
		free_contig_range(outer_start, start - outer_start);
	if (end != outer_end)
		free_contig_range(end, outer_end - end);

	undo_isolate_page_range(pfn_max_align_down(start),
				pfn_max_align_up(end), migratetype);
	return ret;
}
\end{lstlisting}

Pierwszym krokiem jest wywołanie w~8 linii z~funkcji
\code|start_isolate_page_range|.  Jej celem jest zmiana typu
bloków stron na izolowany typ migracji (\ang{isolate}) i~przeniesienie
wszystkich wolnych stron należących do tych bloków na listy tego typu.
Pomimo, że izolowane strony są przechowywane na liście wolnych stron,
i~formalnie są pod kontrolą alokatora stron, nie są one nigdy
alokowane.  W~związku z~tym, strony z~podanego zakresu nie zostaną
zaalokowane dla innych wątków jądra, które mogą żądać alokacji
w~trakcie działania funkcji \code|alloc_contig_range|.

Kolejnym krokiem jest wywołanie w~11 linii funkcji
\code|__alloc_contig_migrate_range|.  Jej zadaniem jest
zidentyfikowanie wszystkich zajętych stron z~zakresu
$\left<\mathrm{start}, \mathrm{end}\right)$ i~zmigrowanie ich do
innego obszaru pamięci.

Po tych dwóch krokach w~zasadzie wszystkie strony z~interesującego nas
zakresu powinny być wolne.  Jednak, zgodnie z~opisem w~podrozdziale
\ref{sec:pcp-lists}, strona może być wolna, ale nie znajdować się na
liście wolnych stron.  Dlatego, w~dalszej części, w~liniach 13--14
wszystkie strony przenoszone są z~list PCP i~wstawiane z~powrotem na
listy wolnych stron.

Po tych operacjach wszystkie strony w~zakresie $\left<\mathrm{start},
\mathrm{end}\right)$ są wolne, jednak z~uwagi na sposób działania
algorytmu bliźniaków, strona identyfikowana przez \code|start|
nie musi wcale być poprawną wolną stroną.  Wynika to z~faktu, że
w~procesie zwalniania stron (linia \ref{alg:buddy-free:join} algorytmu
\ref{alg:buddy-free}) mogła ona zostać połączona ze swoją bliźniaczą
stroną tworząc wolną stronę o~wyższym rzędzie.  Z~tego powodu,
w~liniach 16--20 funkcja \code|alloc_contig_range| wyszukuje tę
początkową stronę -- „zewnętrzny początek” zakresu.

W~linii 22 następuje właściwe zaalokowanie stron, tj.\ usunięcie ich
z~list wolnych stron, na skutek czego alokator stron zupełnie nie
zdaje sobie sprawy z~ich istnienia (co jest rzecz jasna równoważne
z~alokacją tych stron).  W~procesie tym, wszystkie strony których rząd
jest niezerowy są dzielone na strony rzędu zerowego.

Należy zauważyć, że tak samo jak na początku zakresu, tak samo i~na
końcu możemy trafić na stronę, które przekracza interesujący nas
zakres.  Dlatego też funkcja \code|isolate_freepages_range|,
która dokonuje alokacji, zwraca „zewnętrzny koniec” zakresu, który
może wypadać poza żądanym końcem zakresu.

Po tych wszystkich operacjach, funkcja zaalokowała strony z~zakresu
$\left<\mathrm{outer\_start}, \mathrm{outer\_end}\right)$, który może
być większy od żądanego $\left<\mathrm{start}, \mathrm{end}\right)$.
Niepotrzebne strony są zwalniane z~powrotem do alokatora stron
w~liniach 26--29.

Ostatnim krokiem jest przywrócenie pierwotnego typu migracji blokom
stron, na których funkcja operowała, co jest dokonane w~linii 31.


\section{Migracja zakresu stron}\label{sec:alloc-contig-migrate-range}

Jak w~takim razie wygląda migracja stron?  Funkcja
\code|alloc_contig_range| woła \code|__alloc_contig_migrate_range|,
której zadaniem jest zmigrowanie zakresu stron.  Wydruk
\ref{lst:alloc-contig-migrate-range} przedstawia tę funkcję (ponownie
w~skróconej wersji, bez sprawdzania błędów i~komentarzy).

\begin{lstlisting}[float=tbhp,caption={Skrócony wydruk funkcji
    \code|__alloc_conting_migrate_range| z Linuksa 3.5.},label=lst:alloc-contig-migrate-range]
static int __alloc_contig_migrate_range(unsigned long start, unsigned long end)
{
	unsigned long pfn = start;
	unsigned int tries = 0;
	int ret = 0;

	struct compact_control cc = {
		.nr_migratepages = 0,
		.order = -1,
		.zone = page_zone(pfn_to_page(start)),
		.sync = true,
	};
	INIT_LIST_HEAD(&cc.migratepages);

	migrate_prep_local();

	while (pfn < end || !list_empty(&cc.migratepages)) {
		if (list_empty(&cc.migratepages)) {
			cc.nr_migratepages = 0;
			pfn = isolate_migratepages_range(cc.zone, &cc,
							 pfn, end);
			tries = 0;
		} else if (++tries == 5) {
			ret = ret < 0 ? ret : -EBUSY;
			break;
		}

		ret = migrate_pages(&cc.migratepages,
				    __alloc_contig_migrate_alloc,
				    0, false, MIGRATE_SYNC);
	}

	putback_lru_pages(&cc.migratepages);
	return ret > 0 ? 0 : ret;
}
\end{lstlisting}

Funkcja działa w~pętli dopóki wszystkie zajęte strony z~zakresu
$\left<\mathrm{start}, \mathrm{end}\right)$ nie zostaną zmigrowane.

Funkcja przechowuje kolejkę stron, które czekają na zmigrowanie
w~liście \code|cc.migratepages|, która (jeżeli jest pusta) jest
uzupełniana przez funkcję \code|isolate_migratepages_range|.

Funkcja ta skanuje podany zakres stron od początku zakresu szukając
strony, które mogą zostać zmigrowane, aż znajdzie 32 strony (ten
arbitralny bądź co bądź limit, zdefiniowany jest przez stałą
\code|COMPACT_CLUSTER_MAX|) lub dojdzie do końca zakresu.
Wszystkie strony zapisywane są na wspomnianej już liście.

Strony te są migrowane przez funkcję \code|migrate_pages|
i~jeżeli wszystko się powiedzie, funkcja kończy się powodzeniem po
przeniesieniu wszystkich zajętych stron do innego obszaru.


\subsection{Migracja pojedynczej strony}

\TODO{Zredagować ten akapit} W~tym miejscu należałoby umieścić pewne
krótki opis jak ten mechanizm działa.  Składa się on zasadniczo
z~czterech kroków przedstawionych w~algorytmie \ref{alg:migrate}.

\begin{algorithm}
\caption{Migracja strony $p$}
\label{alg:migrate}
\begin{algorithmic}[1]
\Procedure{MigratePage}{$p$}
    \State $p' \gets$ \Call{AllocPage}{$0$}
    \State skopiuj zawartość $p$ do $p'$
    \State uaktualnij odwołania do $p$ tak aby wskazywały na $p'$
    \State \Call{FreePage}{$p$, $0$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\TODO{Za duża „strony”.} W~zasadzie najbardziej skomplikowanym krokiem
jest uaktualnienie odwołań do strony tak, aby wskazywały na nową
stronę $p'$.  Ponieważ istnieje wiele rodzajów stron ruchomych (strony
anonimowe, bufory dyskowe itp.), jest to krok specyficzny dla danej
strony.

Przykładowo dla stron anonimowych wiązałoby się to z~uaktualnieniem
tablicy translacji stron MMU tak, aby wskazywały w~nowe miejsce,
a~także wyczyszczeniem pamięci TLB (\ang{Translate Lookaside Buffer}),
aby nie posiadała, żadnych nieaktualnych wpisów.


\section{Wybór zakresu stron}

Funkcja \code|alloc_contig_range| potrafi zaalokawać zakres
stron (wykonując przy tym migrację stron w~tym zakresie, które są
zajęte), ale w~jaki sposób CMA wybiera zakres do wykonania alokacji?
Odpowiedzi na to pytanie należy szukać w~funkcji
\code|dma_alloc_from_contiguous|, której skróconą wersję
przedstawia wydruk \ref{lst:dma-alloc-from-contiguous}.

\begin{lstlisting}[float=tbhp,caption={Skrócony wydruk funkcji
    \code|dma_alloc_from_contiguous| z Linuksa
    3.5.},label=lst:dma-alloc-from-contiguous]
struct page *dma_alloc_from_contiguous(struct device *dev, int count,
				       unsigned int align)
{
	unsigned long mask, pfn, pageno, start = 0;
	struct cma *cma = dev_get_cma_area(dev);

	mask = (1 << align) - 1;
	for (;;) {
		pageno = bitmap_find_next_zero_area(cma->bitmap, cma->count,
						    start, count, mask);
		if (pageno >= cma->count)
			return NULL;
		pfn = cma->base_pfn + pageno;
		if (alloc_contig_range(pfn, pfn + count, MIGRATE_CMA) == 0) {
			bitmap_set(cma->bitmap, pageno, count);
			return pfn_to_page(pfn);
		}
		start = pageno + mask + 1;
	}
}
\end{lstlisting}

Funkcja używa metody „pierwszy pasujący” do wyszukania pasującego
obszaru w~bitmapie (linie 9--10).  Po wybraniu obszaru, wołana jest
funkcja \code|alloc_contig_range|, aby dany obszar zaalokować
(linia 14) i~jeżeli się to powiedzie, oznacza obszar w~bitmapie jako
zajęty i~zwraca wynik (linie 15--16).

Aby nie załączać zbyt wielu szczegółów, podrozdział
\ref{sec:alloc-contig-range} nie opisuje sytuacji, w~których alokacja
może się nie powieść, ale takie istnieją\footnote{W~istocie, jest ich
  dość sporo i~obecnie wraz z~innymi deweloperami Linuksa staram się
  wyszukać i~wyeliminowaniem takie sytuacji.  Linux, a~szczególnie
  zarządzanie pamięcią w~Linuksie, jest jednak skomplikowany i~czasem
  trudno prześledzić wszystkie zależności i~interakcje pomiędzy
  komponentami, które mogą prowadzić do błędu alokacji.} i~z~tego
powodu, funkcja \code|dma_alloc_from_contiguous| działa w~pętli
w~ten sposób, że jeżeli alokacja jednego obszaru się nie powiedzie,
w~następnej iteracji funkcja próbuje zaalokować kolejny obszar.

\section{Regiony CMA}

Bitmapa, w~której śledzone są wolne i~zajęte strony zapisana jest
w~strukturze \code|cma|, która opisuje pojedynczy region pamięci,
który jest pod kontrolą CMA.  Ma ona następujące pola:

\begin{tabular}{lll}
\code|unsigned long|   & {\bf \code|base_pfn|} & Identyfikator początkowej strony w~regionie. \\
\code|unsigned long|   & {\bf \code|count|}    & Liczba strony w~regionie. \\
\code|unsigned long *| & {\bf \code|bitmap|}   & Bitmapa zajętych stron. \\
\end{tabular}
