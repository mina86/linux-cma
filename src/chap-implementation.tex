\section{Sposób działania alokatora \acc{CMA}}

Podstawowym założeniem mechanizmu \acc{CMA} jest umożliwienie
alokowania dużych obszarów ciągłych fizycznie bez konieczności
rezerwacji na wyłączność dużej ilości pamięci.  Aby to umożliwić,
interfejs \acc{CMA} korzysta z~mechanizmu migracji stron opisanego
pokrótce w~podrozdziale \ref{sec:migratetype}.  Ogólny zarys alokacji
z~regionów \acc{CMA} przedstawiony jest na rysunku
\ref{fig:cma-alloc-algo} a~niniejszy rozdział opisze ją w~większych
szczegółach.

\begin{figure}[tbp]
  \includegraphics[width=\textwidth]{build/cma-alloc-algo.eps}
  \caption{Schemat działania alokatora \acc{CMA}.}
  \label{fig:cma-alloc-algo}
\end{figure}


\subsection{Typ migracji \acc{CMA}}\label{sec:migrate-cma}

Migracja jest możliwa tylko dla stron ruchomych.  Niestety, przed
zaimplementowaniem alokatora \acc{CMA}, Linux nie posiadał mechanizmu,
który pozwalałby zagwarantować istnienie dużego obszaru, w~którym
strony są albo wolne, albo ruchome.  Ponieważ (jak opisałem
w~podrozdziale \ref{sec:type-change}) jądro dopuszcza alokacje
nieruchomych stron z~bloków ruchomych, a~także posiada mechanizm na
skutek którego bloki zmieniają swój typ, aby mechanizm \acc{CMA} mógł
działać poprawnie, należało stworzyć nowy typ migracji\,---\,nazwanym
po prostu typem migracji cma\,---\,który posiada dwie bardzo istotne
cechy: (i) z~bloków oznaczonych typem cma mogą być alokowane tylko
strony ruchome oraz (ii) blok oznaczony typem cma nie zmienia swojego
typu (na skutek działania alokatora stron).

O~ile pierwsza właściwość jest stosunkowo prosta do osiągnięcia,
zagwarantowanie niezmienności typu bloku stron wymagało
zidentyfikowania wszystkich sytuacji, w~których blok może zmienić swój
typ i~dodanie odpowiednich warunków zapewniających, że niepożądana
zmiana nie nastąpi.

\subsection{Alokowanie wybranego obszaru pamięci}\label{sec:alloc-contig-range}

Posiadając gwarancję, że dany zakres składa się jedynie z wolnych
i~ruchomych stron, można przystąpić do jego alokacji.  Drugim krokiem
implementowania alokatora \acc{CMA} było zatem stworzenie funkcji, która
dostaje jako argument zakres stron, a~następnie migruje wszystkie
zajęte strony, a~wolne usuwa z~listy wolnych stron.  Właśnie to czyni
funkcja \code|alloc_contig_range|.

Pierwszym krokiem wykonywanym przez tę funkcję jest zmiana typu bloków
stron na izolowany typ migracji.  Pomimo, że izolowane strony są
przechowywane na liście wolnych stron i~są pod kontrolą alokatora
stron, nie są używano do zaspokajania żądań alokacji.  W~ten sposób,
funkcja \code|alloc_contig_range| uzyskuje gwarancje, że strony, na
których operuje nie zostaną zaalokowane dla innych wątków jądra.

W~dalszej części wołana jest kolejna stworzona przeze mnie funkcja
\code|__alloc_contig_migrate_range|, której zadaniem jest
zidentyfikowanie i~zmigrowanie wszystkich zajętych stron z~podanego
zakresu.  Funkcja szuka stron, które mogą zostać zmigrowane, po czym
zleca migracje funkcji \code|migrate_pages|.

Gdy strony są już wolne i~przechowywane na liście stron izolowanych,
funkcja \code|alloc_contig_range| może usunąć je z~tej listy, na
skutek czego alokator stron zupełnie nie zdaje sobie sprawy z~ich
istnienia (co jest równoważne z~alokacją tych stron).

Aby zakończyć alokację wystarczy już przywrócić pierwotny typ bloku
(gdyż na początku został on zmieniony na typ izolowany) i~zwrócić
wskaźnik na pierwszą zaalokowaną stronę.


\subsection{Wybór zakresu stron}\label{sec:alloc-from-contig}

Alokacje \acc{CMA} odbywają się z~regionów, które są rezerwowane przy
starcie systemu.  Dla każdego zarezerwowanego obszaru tworzona jest
struktura \code|cma| reprezentujące pojedynczy kontekst \acc{CMA}.  Posiada
ona następujące pola:

\begin{tabular}{lll}
\textbf{\code|base_pfn|} & Identyfikator pierwszej strony w~regionie. \\
\textbf{\code|count|}    & Liczba strony w~regionie. \\
\textbf{\code|bitmap|}   & Bitmapa zajętych stron. \\
\end{tabular}

Pierwsze dwa identyfikują obszar w~pamięci fizycznej, gdzie znajduje
się kontekst \acc{CMA}, a~ostatnia jest mapą określającą, które ze stron
zostały zaalokowane przez \acc{CMA}.  Bitmapa jest wykorzystywana przez
funkcję \code|dma_alloc_from_contiguous|, która używa metody „pierwszy
pasujący” do wyszukania dostatecznie dużego obszaru niezaalokowanych
przez \acc{CMA} stron.  Po wybraniu obszaru, wołana jest funkcja
\code|alloc_contig_range|, aby dany obszar zaalokować i~jeżeli się to
powiedzie, oznacza obszar w~bitmapie jako zajęty i~zwraca wynik.

Aby nie załączać zbyt wielu szczegółów, poprzedni podrozdział nie
opisuje sytuacji, w~których alokacja się nie powodzi, które niestety
istnieją\footnote{W~istocie, jest ich dość sporo i~obecnie wraz
  z~innymi deweloperami Linuksa staram się wyszukać i~wyeliminować
  takie sytuacji.  Linux, a~szczególnie zarządzanie pamięcią
  w~Linuksie, jest jednak skomplikowany i~czasem trudno prześledzić
  wszystkie zależności i~interakcje pomiędzy komponentami, które mogą
  prowadzić do błędu alokacji.}.  Z~tego powodu funkcja
\code|dma_alloc_from_contiguous| działa w~pętli i próbuje alokować
różne obszaru pamięci aż do skutku lub wyczerpania możliwych obszarów.
