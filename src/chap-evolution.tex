\chapter{Ewolucja Contiguous Memory Allocatora}

Z~uwagi na skomplikowany charakter problemu, moje prace nad alokacją
dużych ciągłych fizycznie obszarów pamięci trwały dość długo.  Od
interfejsu \textit{Physical Memory Manager} (\acc{PMM})
\autocite{patch:pmm}, aż do wersji \textit{Contiguous Memory
  Allocatora} \acc{CMA}, która została ostatecznie dołączona do oficjalnego
wydania Linuksa \autocite{patch:cma-24} minęły prawie trzy lata i~choć
część opóźnienia wynikało z~faktu, że równocześnie pracowałem nad
podsystemem \acc{USB} Linuksa, dużo czasu było wymagane, gdyż musiałem
zrozumieć kod zarządzania pamięcią jądra oraz zadowolić wszystkich
zainteresowanych deweloperów Linuksa.  W~rozdziale tym opiszę proces,
który doprowadził do powstania \acc{CMA} w~obecnej formie.


\section{Physical Memory Manager}\label{sec:evo-pmm}

Menadżer \acc{PMM} został wysłany na listę dyskusyjną jądra Linux
w~maju 2009 roku \autocite{patch:pmm}.  Z~punktu widzenia alokacji
pamięci nie był rewolucyjny, gdyż opierał się na rezerwacji puli
pamięci, z~której sterowniki mogły później alokować bufory.  To co
wyróżniało \acc{PMM} spośród podobnych rozwiązań to kilka dodatkowych
interfejsów, które udostępniał.

Po pierwsze, umożliwiał alokowanie pamięci fizycznej nie tylko
sterownikom działającym w~przestrzeni jądra, ale także programom
działającym pod kontrolą systemu (w~przestrzeni użytkownika).  Dzięki
temu aplikacja mogła zaalokować pamięć i~przekazać ją dekoderowi \acc{JPEG},
który umieszczał zdekodować plik bezpośrednio w~buforach dostępnych
dla aplikacji. W~ten sposób, kod odpowiedzialny za interakcję
z~przestrzenią użytkownika był umieszczony w~jednym miejscu tworząc
jednolity interfejs i~brak konieczności powtarzania implementacji
w~sterownikach urządzeń.

Co więcej, ponieważ dowolny bufor \acc{PMM}, mógł zostać przekazany do
sterownika, aplikacja była w~stanie budować potoki.  Dla przykładu, po
zdekodowaniu obrazka \acc{JPEG}, mógł on zostać przekazany do układu
skalującego, a~następnie jednostki, która go obróciła.  Istotne jest,
iż w~takim potoku, dane nigdy nie były niepotrzebnie kopiowane\,---\,za
każdym razem dokonywana była na nich jakaś operacja.

Menadżer \acc{PMM} integrował się również z~mechanizmem współdzielenia
pamięci Systemu V~(tj.\ rodziną funkcji \code|shmget|, \code|shmat|,
\code|shmdt| itp.) wykorzystywanym między innymi przez system X~Window
do umożliwienia współdzielenia map bitowych pomiędzy klientem
i~serwerem (działającymi na tej samej maszynie) bez konieczności
przysłania danych przez gniazdo sieciowe.  Dzięki temu aplikacja mogła
przekazać obrazek przetworzony w~sprzętowym potoku bezpośrednio do
serwera X11 bez konieczności kopiowania danych między buforami.

Wszystkie operacje \acc{PMM} działały w~czasie \BigO{\log n} co
powodowało, że \acc{PMM} skalował się nawet do tysięcy buforów
i~wystarczał dla potrzeb takich aplikacji jak odtwarzacz wideo, czy
program do nagrywania obrazu z~kamery.  Pierwotna wersja korzystała
z~algorytmu „najlepszy pasujący”, ale był on wyodrębniony od reszty
kodu, tak iż był łatwy do zastąpienia innym, jeżeli zaistniałaby taka
potrzeba.

Głównymi zastrzeżeniami odnośnie \acc{PMM} było rezerwowanie na
wyłączność pamięci, a~także brak mechanizmów, które byłyby w~stanie
zapobiec problemom z~fragmentacją dostępnej puli.  Niemniej, pomimo,
że kod nie trafił do oficjalnego wydania Linuksa, był on z~powodzeniem
stosowany w~wersji źródeł jądra utrzymywanym przez firmę Samsung
Electronics.


\section{Contiguous Memory Allocator}

Menadżer \acc{PMM} okazał się wystarczający do wielu zastosowań jednak
konieczność utrzymywania go poza oficjalnymi wydaniami Linuksa stawała
się uciążliwa.  Co więcej, z~czasem zidentyfikowane zostały kolejne
wymagania funkcjonalne, które zmusiły mnie do wznowienia prac nad
problemem.  W~ten sposób rozpocząłem pracę nad mechanizmem \acc{CMA},
który na przełomie dwudziestu miesięcy przeszedł przez 24 rewizje
zanim został dołączony do Linuksa 3.5.

\subsection{Wersje 1--5: Początki}\label{sec:evo-cma}

Pierwsza wersja \acc{CMA}, opublikowana\footnote{\autocite{patch:cma-24}
  posiada odnośniki do wszystkich wersji \acc{CMA}, dlatego jeżeli czytelnik
  jest zainteresowany konkretną wersją, odsyłam do tej pozycji.}
w~lipcu 2010 roku, była w~głównej mierze szkieletem do zarządzania
różnymi regionami pamięci i~przypisywania tych regionów do różnych
sterowników.

Rdzeń \acc{CMA} nie posiadał żadnego alokatora i~zamiast tego udostępniał
prosty interfejs do tworzenia i~podłączania różnych algorytmów.
Opublikowana wersja posiadała, podobnie jak \acc{PMM}, prosty alokator
korzystający z~metody „najlepszy pasujący”, ale dzięki swojej
architekturze, \acc{CMA} pozwalał podmienić go w~bardzo prosty sposób.

Interfejs parametrów przekazywanych do jądra przez program rozruchowy
pozwalał określać jakie regiony pamięci należy zarezerwować oraz które
sterowniki powinny mieć do nich dostęp.  Głównym zastosowaniem był
tutaj dekoder wideo (\ang{Multi-Format Codec}, \acc{MFC}) na
platformie SP5V1100, który wymagał, aby różne dane były przechowywane
w~różnych bankach pamięci.  Pozwalało to na zwiększenie szybkości
dostępu do danych dzięki zastosowaniu odczytu z~dwóch banków pamięci
jednocześnie.  Dzięki infrastrukturze \acc{CMA} sterownik \acc{MFC}
nie musiał być świadom na jakiej platformie działał, gdyż ewentualne
mapowanie pomiędzy typami żądań i~bankami pamięci odbywało się
w~\acc{CMA}.

Ponadto, dzięki odczytywaniu konfiguracji z~parametrów jądra, proste
było testowanie, bez konieczności ponownej kompilacji jądra, różnych
konfiguracji regionów, takich jak rozmiar i minimalne wyrównania
alokowanych buforów, ale również listy sterowników korzystających
z~poszczególnych regionów, a~nawet użytego algorytmu alokacji.
Ułatwiało to dobór parametrów, które najlepiej pasują dla konkretnego
zastosowania systemu.

Kod parsujący parametry jądra okazał się jednak dość kontrowersyjny.
Zarzucano mu, iż jest zbyt skomplikowany, tak samo zresztą jak sam
format parametrów.  Co więcej, na liście dyskusyjnej pojawiły się
głosy sugerujące, iż przynajmniej część konfiguracji powinno dać się
zmienić w~trakcie działania systemu.  Z~tych powodów, kolejna wersja
\acc{CMA} uprościła format parametrów, a~także dodała interfejs sysfs, który
pozwalał zmieniać przypisanie sterowników do regionów w~trakcie
działania systemu.

Ten fragment kodu był dalej upraszczany w~trzeciej i~czwartej wersji
\acc{CMA}.  Interfejs tekstowy stał się całkowicie opcjonalny i~dostępny
tylko jeżeli włączone zostają odpowiednie opcje kompilacji jądra.

Z~mniejszych zmian, druga wersja zmieniła sposób wczytywania
algorytmów alokowania\,---\,w~odróżnieniu od poprzedniej wersji, możliwe
się stało budowanie algorytmów jako modułów\,---\,a~także dodała
możliwość operowania na prywatnych regionach dostępnych tylko dla
danego sterownika (funkcja ta została zasugerowana przez Jonathana
Corbeta).

\subsection{Wersje 6--9: Współdzielenie pamięci}

Aż do wersji piątej alokator \acc{CMA} bazował na idei rezerwowania na
wyłączność obszaru pamięci, który nie jest zupełnie używany, jeżeli
żadne urządzenie go nie wykorzystuje.  W~wersja szóstej, rozpocząłem
prace nad implementacją mechanizmu migracji, który pozwalał na
współdzielenie pamięci \acc{CMA} z~systemem.

Początkowo implementacja bazowała na kodzie Kamezawa'y
Hiroyuki\,---\,który był oparty na infrastrukturze umożliwiającym
usuwanie (dodawanie) kości \acc{RAM} z~(do) komputera bez konieczności
jego wyłączania (\ang{memory hot-plugging})\,---\,i~nie należał do
bardzo stabilnych.  Kolejne wersje \acc{CMA} przynosiły iteracyjne
poprawki zwiększające stabilność i~niezawodność alokacji.

Szósta wersja dodała również operację przypinania zaalokowanych
buforów (\ang{pinning}), którą zasugerował Johan Mossberg.  Interfejs
ten miał umożliwiać przenoszenie buforów \acc{CMA} jeżeli żadne
urządzenie z~nich w~danej chwili nie korzysta, co zmniejszyłoby
fragmentację regionów \acc{CMA}.

Z~czasem stawało się oczywiste, iż pisząc \acc{CMA} powinienem się skupić na
najistotniejszym aspekcie alokatora, gdyż nie uda się od razu
rozwiązać wszystkich problemów.  Dlatego w~wersji siódmej usunąłem
z~\acc{CMA} mechanizm przypisywania regionów \acc{CMA} do sterowników.  Począwszy
od tego wydania, problem ten miał być rozwiązany poza kodem \acc{CMA}.
Zmiana ta zmniejszyła implementację, a~co za tym idzie, uprościła jej
utrzymywanie i~rozwój.

\subsection{Wersje 10--16: Integracja z~\acc{DMA} \acc{API}}

W~trakcie współpracy ze społecznością programistów Linuksa nad
poprzednimi wersjami \acc{CMA} okazało się oczywiste, że alokator musi
być w~większym stopniu zintegrowany z~\acc{DMA} \acc{API} jądra,
będącym standardowym interfejsem, który sterowniki mogą wykorzystywać,
by alokować bufory \acc{DMA}.  Dlatego w~wersji dziesiątej \acc{CMA},
Marek Szyprowski, opiekun \acc{DMA} \acc{API} dla architektury
\acc{ARM}, dodał poprawki modyfikujące interfejs \acc{DMA} \acc{ARM}-a
tak, aby korzystał z~\acc{CMA}.  Osobiście byłem w~mniejszym stopniu
zaangażowany w~te zmiany pracując raczej głębiej w~podsystemie
zarządzania pamięcią.

Na skutek tych modyfikacji funkcje \acc{CMA} przeznaczone dla
sterowników stały się niepotrzebne i~w~związku z~tym usunięte.
Począwszy od wersji dziesiątej, sterowniki powinny korzystać
z~\acc{DMA} \acc{API} i~nie powinny być nawet świadome obecności
\acc{CMA} w~systemie.  Pociągnęło to za sobą również usunięcie
mechanizmu przypinania buforów, jednak nie był on do niczego używany
i~stanowił raczej teoretyczny pomysł, więc jego usunięcie nie miało
żadnych negatywnych skutków.

Kolejne wydania \acc{CMA} aż do wersji 16 skupiały się w~głównej mierze na
stabilizacji interfejsu pomiędzy \acc{CMA} a~\acc{DMA} \acc{API}, a~także małych
iteracyjnych poprawkach do kodu alokatora.

\subsection{Wersje 17--24: Bazowanie na kodzie zagęszczania}

Po rozmowach z~Melem Gormanem doszedłem do wniosku, że \acc{CMA} powinna
bazować na mechanizmie zagęszczania \autocite{bib:compaction,
  bib:supporting-large-contig-regions}, a~nie jak w~poprzednich
wersjach na interfejsie wymiany pamięci \acc{RAM} bez wyłączania komputera.
W~związku z~tym, w~wersji 17 przepisałem podstawowe funkcji alokujące
pamięć.

Interfejs \acc{CMA} już w~zasadzie się ustabilizował i nie pozostało już nic
innego niż na bieżąco wyszukiwać i~poprawiać błędy w~implementacji.
Z~czasem mechanizm \acc{CMA} budził coraz większe zainteresowanie i~coraz
więcej osób przeglądało jego kod, co tylko pomogło w~naprawianiu
wszelkich problemów.

W~kwietniu 2012 roku 24 wersja alokatora \acc{CMA} została wydana.
Uzyskała pozytywne opinie od Arnda Bergmanna, Mela Gormana i Kamezawa
Hiroyuki i~była przetestowana przez kilka innych osób.  W~tym momencie
mechanizm \acc{CMA} był dostatecznie stabilny i~niezawodny, aby Andrew
Morton dołączył go do swojego drzewa \code{-mm}, które następnie
zostało połączone z~oficjalnymi źródłami będącymi pod opieką Linusa
Torvaldsa.

\section{Współpraca ze społecznością Linuksa}

Alokator \acc{CMA} był pierwszym tak dużym i~skomplikowanym projektem, który
starałem się dołączyć do oficjalnego wydania Linuksa.  Moje
wcześniejsze poprawki trafiały do podsystemu \acc{USB} i~były mniejsze
i~znacznie mniej inwazyjne.

Było to cenne doświadczenie, które nauczyło mnie, iż często istotne
jest tworzenie kodu, który skutecznie rozwiązuje najistotniejszy
problem zamiast częściowo poruszać wiele różnych zagadnień.  Śledząc
drogę jaką przeszedł mechanizm \acc{CMA} łatwo zauważyć, jak jego
zakres się zmniejszał, oferując w~zamian rozwiązanie coraz wyższej
jakości.

Co więcej, prace nad mechanizmami \acc{PMM} i~\acc{CMA} pokazują, że
współpraca z~programistami Linuksa może być trudna\,---\,czasami wręcz
wątpiłem, czy mój kod kiedykolwiek trafi do jądra\,---\,ale przeważnie
powoduje, że akceptowany staje się tylko kod najwyższej jakości.
Pomimo niezaprzeczalnych trudności, w~szczególności na początku
tworzenia \acc{CMA}, muszę przyznać, iż praca nad dużym projektem
wolnego oprogramowania i~ostateczna akceptacja poprawki w~jądrze, były
warte wielu wieczorów przesiedzianych przy poszukiwaniu szczególnie
nieuchwytnych blędów w~kodzie.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{lll}
Osoba             & Afiliacja                & Tag \\
\hline
Arnd Bergmann     & \acc{IBM}                & Acked \\
Mel Gorman        & \acc{IBM}, później Novell Inc. & Acked \\
Kamezawa Hiroyuki & Fujitsu Ltd.             & Reviewed \\
Barry Song        & \acc{CSR} plc            & Tested \\
Benjamin Gaignard & ST-Ericsson              & Tested \\
Ohad Ben-Cohen    & Wizery Ltd.              & Tested \\
Rob Clark         & Texas Instruments Inc.   & Tested \\
\end{tabular}
\end{center}
\caption[Afiliacje osób wymienionych w~ostatniej wersji
  \acc{CMA}.]{Afiliacje osób wymienionych w~ostatniej wersji
  \acc{CMA}.  Tag określa jaki był wkład danej osoby: Acked oznacza,
  że osoba przejrzała kod i~nie zauważyła w~nim żadnych błędów;
  Reviewed oznacza, że osoba wykonała dogłębną analizę kodu; a~Tested
  oznacza, że osoba przetestowała kod.}
\label{tab:cma-ppl}
\end{table}

Warto też zwrócić uwagę, że komentowało i~sugerowało poprawki do \acc{CMA}
dużo osób powiązanych z~różnymi firmami (tabela \ref{tab:cma-ppl}
przedstawia afiliacje niektórych z~takich osób), a~pomimo to, nie
wpływało to na opinię o~kodzie.  Szczególnie atrakcyjne w~społeczności
programistów Linuksa jest to, że nie ma znaczenia dla kogo dana osoba
pracuje, ale tylko techniczne aspekty kodu, który tworzy.
