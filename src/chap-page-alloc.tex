\chapter{Zapoznanie z~alokatorem stron}

Ponieważ CMA integruje się dość mocno z~podsystemem zarządzania
pamięci (\ang{memory management}), do jej zrozumienia potrzeba
choć ogólnej wiedzy na temat tego w~jaki sposób Linuks zarządza
pamięcią \TODO{powtórzenie zarządza pamięcią}.

Linuks posiada wiele mechanizmów dzięki którym sterowniki mogą
alokować pamięć.  Począwszy od funkcji \lstinline|kmalloc()|
i \lstinline|vmalloc()|, poprzez mechanizmy puli pamięci, aż do
alokatora czasu bootowania i~alokatorów pamięci dostępnej dla urządzeń
zewnętrznych \cite[rozdział 8]{bib:ldd3}.  Pomimo, tak dużej liczby
interfejsów, wiele z~nich sprowadza się do alokatora stron (\ang{page
  allocator}), który jest sercem całego podsystemu zarządzania
pamięcią.

\section{Algorytm bliźniaków}

\begin{wrapfigure}{o}[1.5cm]{0.3\textwidth}
\begin{center}
\includegraphics[width=0.25\textwidth]{build/alloc-free-cycle.eps}
\end{center}
\caption{Graficzna reprezentacja cyklu alokacji i~zwalniania buforów
  w~algorytmie bliźniaków.}
\end{wrapfigure}

Alokator stron implementuje algorytm bliźniaków (skąd też jego inna
angielska nazwa: {\it buddy system} lub {\it buddy allocator}), który
operuje na blakach o~rozmiarze $2^k$ jednostek.  W~przypadku Linuksa
jednostką jest pojedyncza strona fizyczna, a~na $k$~narzucone jest
ograniczenie $k < \mathrm{MAX\_ORDER}$.  \lstinline|MAX_ORDER| może
zależeć od architektury, na którą Linuks jest kompilowany, ale
zazwyczaj ma wartość $11$ (toteż na potrzeby tej pracy zakładam, iż $0
\le k \le 10$).

W~Linuksie, przez $k$ rozumie się rząd\TODO{może po prostu lepiej
  zostawić „order” i~nie tłumaczyć?} strony (\ang{page order}).
Strona rzędu 0 to pojedyncza strona fizyczna, strona rzędu 1
(\ang{1-order page}) to dwie strony fizyczne itd.\ aż do strony rzędu
10, czy też strony maksymalnego rzędu (\ang{max order page}), która
składa się z~1024 stron fizycznych.  Ogólnie, strona rzędu $n$ składa
się z~dwóch stron rzędu $n-1$.

Funkcja \lstinline|alloc_pages()|, która jest interfejsem dla
alokatora stron, przyjmuje jako argument właśnie rząd żądanej strony.

Z~powyższego opisu wynikają następujące właściwości alokatora stron.

\begin{itemize}
\item Nie można za jego pomocą zaalokować mniej niż jednej strony,
  tj.\ 4096 bajtów.
\item Interfejs zwyczajnie nie pozwala alokować obszarów, których
  rozmiar nie jest potęgą dwójki.
\item Gdyby jednak chcieć zaalokować taki obszar, wiązałoby się to
  z~potencjalnie dużą fragmentacją wewnętrzną.  Dla przykładu bufor
  dla kolorowej tekstury o~rozmiarze $512 \times 512$ pikseli
  wymagałby obszaru o~rozmiarze \unit[1]{MiB}, z~których
  \unit[256]{KiB}, a~więc \nicefrac{1}{4}, byłoby nieużywane.
\item Alokator stron nie jest w~stanie zaalokować obszaru większego
  niż \unit[4]{MiB}.  Z~tego powodu, nie nadaje się do alokowania
  ciągłego fizycznie buforu dla 5 megapikselowej kamery, czy nawet dla
  pojedynczej ramki {\it full HD}.
\end{itemize}

Jak zatem działa algorytm bliźniaków?  Alokator posiada listę wolnych
stron, których rząd jest pomiędzy $0$ a~$10$.  W~Linuksie zrealizowane
jest to poprzez 11 list dwukierunkowych, gdzie każda przeznaczona jest
dla stron o~konkretnym rzędzie.

Gdy sterownik chce zaalokować stronę rzędu $n$, alokator sprawdza
odpowiednią listę.  Jeżeli jest ona pusta, przechodzi do listy ze
stronami rzędu $n+1$, aż znajdzie wolną stronę (lub dojdzie do
maksymalnego rzędu, co sygnalizuje nieudaną alokację.  Jeżeli uzyskana
w~ten sposób strona ma rząd większy niż żądany, jest ona dzielona na
pół, aż do osiągnięcia żądanego rozmiaru.  Strony, które powstały na
skutek podziału większej strony na pół, nazywamy stronami
bliźniaczymi.  Cały proces ilustruje algorytm \ref{alg:buddy-alloc}

\begin{algorithm}\label{alg:buddy-alloc}
\caption{Alokacja strony rzędu $k$ w~algorytmie bliźniaków}
\begin{algorithmic}[1]
\Require $0 \leq k < \mathrm{MAX\_ORDER}$
\Function{AllocatePage}{$k$}
    \State $i \gets k$
    \While {lista stron rzędu $i = \emptyset$}
        \State $i \gets i + 1$
        \If {$i = \mathrm{MAX\_ORDER}$}
            \State \Return $\emptyset$
        \EndIf
    \EndWhile

    \State $p \gets$ strona z listy stron rzędu $i$
    \While {$i \neq k$}
        \State $i \gets i - 1$
        \State podziel $p$ na pół na $p_1$ i $p_2$
        \Comment{Strony $p_1$ i $p_2$ nazywamy stronami bliźniaczymi}
        \State $p \gets p_1$
        \State dodaj $p_2$ do listy stron rzędu $i$
    \EndWhile
    \State \Return $p$
\EndFunction
\end{algorithmic}
\end{algorithm}

Przy zwalnianiu, dopóki to możliwe, strona jest łączona ze swoją
bliźniaczą stroną, dzięki czemu strony są dodawane do listy wolnych
stron o~dużym rzędzie.  Proces ten ilustruje algorytm
\ref{alg:buddy-free}

\begin{algorithm}\label{alg:buddy-free}
\caption{Zwalnianie strony $p$ rzędu $k$ w algorytmie bliźniaków}
\begin{algorithmic}[1]
\Procedure{FreePage}{$p$, $k$}
    \While {$k + 1 \neq \mathrm{MAX\_ORDER} \wedge p$ posiada wolną stronę bliźniaczą}
        \State $p' \gets$ strona bliźniacza $p$
        \State usuń $p'$ z~listy wolnych stron
        \State $k \gets k + 1$
        \State $p~\gets$ strona powstała w~wyniku połączenia $p$ i~$p'$ \label{alg:buddy-free:join}
    \EndWhile
    \State dodaj $p$ do listy wolnych stron rzędu $k$\label{alg:buddy-free:add}
\EndProcedure
\end{algorithmic}
\end{algorithm}


\section{Typy migracji}\label{sec:migratetype}

Powyższy opis pomija niektóre szczegóły alokatora stron.  Po pierwsze,
nawet jeżeli w~danej chwili nie istnieje wolna strona o~żądanym
rzędzie, aktywowana jest tzw.\ wolna ścieżka (\ang{slow path}), która
wykorzystuje różne mechanizmy odzyskiwania pamięci (np.\ poprzez
zwalnianie buforów dyskowych, czy w~najgorszym przypadku zabiciu
jednego z~działających procesów).  Mechanizmy te nie są jednak istotne
dla tematyki niniejszej pracy i~dlatego zostały pominięte.

Ważnym czynnikiem są typy migracji (\ang{migratetype}), których jest
sześć: {\it unmovable}, {\it reclaimable}, {\it movable}, {\it cma},
{\it reserve} oraz {\it isolate}).

\begin{itemize}
\item Dla potrzeb tej pracy traktuję typy {\it unmovable}, {\it
  reclaimable} i~{\it reserve} jak jeden typ -- typ nieruchomy.  To
  uproszczenie wynika z~faktu, iż dla CMA-y istotne jest tylko
  rozróżnienie pomiędzy stroną ruchomą i~nieruchomą.
\item Strony które są typu ruchomego charakteryzują się tym, że ich
  adres fizyczny nie jest istotny, w~związku z~czym mogą być
  przeniesione w~inne miejsce pamięci RAM.
\item Typ cma jest nowym typem dodanym przez CMA i~jest opisany
  dokładniej w~podrozdziale \ref{sec:migrate-cma}
\item Typ {\it isolate} jest niejako pseudo-typem, gdyż jeżeli wolna
  strona ma taki typ, nie może ona zostać zaalokowana.  Więcej na
  temat sposobu w~jaki ten typ może być wykorzystywany opisuję
  w~podrozdziale \ref{sec:alloc-contig-range}
\end{itemize}

Jednym z~przykładów stron ruchomych są strony anonimowe działających
procesów.  Ponieważ program odwołują się do nich poprzez mapowania
wirtualne, o~ile tablice translacji zostaną uaktualnione, zawartość
strony może być przeniesiona w~dowolne miejsce.  Podobnie wygląda
sprawa z~buforami dyskowymi i~wieloma innymi strukturami, którymi
zarządza jądro.

Proces przenoszenia ruchomej strony z~jednego miejsca w~inne nazywa
się migracją i wykorzystywany jest między innymi przy obsłudze
hot-swapu pamięci, a~także w~trackie procesu zagęszczania (opisanego
w~\cite{bib:compaction}), którego celem jest zwiększenie liczby
dostępnych stron o~wysokich rzędach.

Wołając funkcję \lstinline|alloc_pages()|, typ migracji strony jest
przekazywany jako argument, co pozwala alokatorowi stron grupować
strony tego samego typu.  Jest to istotne, gdyż mechanizm zagęszczania
nie działa zbyt dobrze jeżeli ruchome strony przelatają się
z~pozostałymi stronami, które nie podlegają migracji.

\section{Grupy stron}

Grupowanie to realizowane jest poprzez podział pamięci na bloki
składające się z~\lstinline|pageblock_nr_pages| stron (czy też
równoważnie na bloki rzędu \lstinline|pageblock_order|).  Konkretne
wartości tych stałych zależą od architektury, no którą jądro zostało
skompilowane, jak i~opcji konfiguracyjnych wybranych w~trakcie
kompilacji.  Niemniej, przeważnie wartość tych stałych to odpowiednio
1024 (stron) i~(rząd) 10 i~właśnie takie są przyjęte w~tej pracy.

\begin{figure}[tbh]
\begin{center}
\includegraphics[width=0.8\textwidth]{build/pages.eps}
\end{center}
\TODO{przetłumaczyć, przerobić na SVG}
\caption{Graficzna reprezentacja organizacji stron pamięci stosowanej
  przez Linuksa.}
\end{figure}

Każdy blok stron (\ang{pageblock}) ma przypisany typ migracji,
a~alokator stron posiada oddzielne listy wolnych stron dla każdego
typu migracji.  Zatem patrząc na algorytm \ref{alg:buddy-alloc} należy
zdawać sobie sprawę, iż rozpatruje on listy wolnych stron danego typu
migracji.

\section{Zmiana typu migracji}\label{sec:type-change}

Należy pamiętać, iż dla jądra zrealizowanie alokacji jest ważniejsze
od trzymania stron o~tym samym typie migracji razem.  Dlatego dla
każdego typu migracji istnieje lista zapasowych (\ang{fallback}) typów
migracji.  Jeżeli alokacja dla żądanego typu migracji nie powiedzie
się, alokator stron będzie próbował z~kolejnymi typami z~list, tak jak
to pokazuje algorytm \ref{alg:buddy-fallback}

Co więcej, jeżeli rząd żądanej strony jest dostatecznie duży, typ
migracji wszystkich wolnych stron w~danym bloku zostaje zmieniano na
ten zgodny z~wywołaniem funkcji \lstinline|alloc_pages()|.

\begin{algorithm}\label{alg:buddy-fallback}
\caption{Alokacja strony rzędu $k$ z~uwzględnieniem typu migracji $m$}
\begin{algorithmic}[1]
\Function{ChangeBlockMigrateType}{$b$, $m$}
\State zmień typ migracji $b$ na $m$
\ForAll {wolnych stron $p' \in b$}
    \State przenieś $p'$ na listę wolnych stron typu $m$
\EndFor
\EndFunction
\Statex
\Function{AllocPageMigrateType}{$k$, $m$}
    \State $f \gets$ lista zapasowych typów migracji dla typu $m$
    \State dodaj $m$ na początek $f$
    \ForAll{$m' \in f$}
        \State $p \gets$ \Call{AllocPage}{$k$} biorąc pod uwagę listy stron typu $m'$
        \If {$p \neq \emptyset$}
            \If {$m \neq m' \wedge k \geq \nicefrac{\mathrm{page\_order}}{2}$}
                \State $b \gets$ blok stron zawierający $p$
                \State \Call{ChangeBlockMigrateType}{$b$, $m$}
            \EndIf
            \State \Return $p$
        \EndIf
    \EndFor
    \State \Return $\emptyset$
\EndFunction
\end{algorithmic}
\end{algorithm}

Podczas zwalniania, gdy strona jest dodawana do listy wolnych stron
(wideczne w~linii \ref{alg:buddy-free:add} algorytmu
\ref{alg:buddy-free}) typ migracji listy, na którą strona trafia
determinowany jest poprzez typ migracji przypisany blokowi stron do
którego dana strona należy.

Istotne jest tutaj, aby zauważyć, iż bloki stron mogą zmieniać swój
typ migracji, a~także, że nawet jeżeli blok ma dany typ migracji,
strony o~innym typie migracji mogą być z~niego przydzielone.


\section{Listy PCP}\label{sec:pcp-lists}

Ostatnim istotnym, z~punktu widzenia CMA, aspektem alokatora stron są
listy PCP.  Ponieważ listy wolnych stron są współdzielone w~obrębie
całego systemu dostęp do nich musi być synchronizowany pomiędzy
wszystkimi procesorami.  Aby uniknąć kosztów związanych
z~synchronizacją, każdy procesor posiada swoje prywatne PCP listy, na
których znajdują się wolne strony rzędu 0.  Biorąc również i~ten
aspekt pod uwagę, alokacja przyjmuje postać przedstawianą w~algorytmie
\ref{alg:buddy-pcp}

\begin{algorithm}\label{alg:buddy-pcp}
\caption{Alokacja strony rzędu $k$ z~typem migracji $m$
  z~uwzględnieniem list PCP}
\begin{algorithmic}[1]
\Function{AllocPageUsePCP}{$k$, $m$}
    \If {$k \neq 0$}
        \State $p \gets$ \Call{AllocPageMigrateType}{$k$, $m$}
    \Else
        \State $l \gets$ lista PCP dla typu migracji $m$
        \If {$l = \emptyset$}
            \State $i \gets 0$
            \Repeat
                \State $p \gets$ \Call{AllocPageMigrateType}{$0$, $m$}
                \If {$p \neq \emptyset$}
                    \State dodaj $p$ do $l$
                    \State $i \gets i + 1$
                \EndIf
            \Until {$i \geq n \vee p = \emptyset$} \Comment{Wartość
              $n$ jest zależna od różnych czynników}
        \EndIf
        \If {$l = \emptyset$}
            \State \Return $\emptyset$
        \Else
            \State $p \gets$ pierwsza strona z $l$
            \State usuń pierwszą stronę z $l$
            \State lista PCP dla typu migracji $m$ $\gets l$
        \EndIf
    \EndIf
    \State \Return $p$
\EndFunction
\end{algorithmic}
\end{algorithm}
